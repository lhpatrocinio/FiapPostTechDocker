input {
  tcp {
    port => 5044
    codec => json
  }
  
  udp {
    port => 5044
    codec => json
  }
}

filter {
  # Normalizar campo microservice se vier como array
  if [microservice] {
    if [microservice][0] {
      # Se for array, pegar o primeiro elemento
      mutate {
        replace => { "microservice" => "%{[microservice][0]}" }
      }
    }
    
    # Limpar caracteres especiais do nome do microservice
    mutate {
      gsub => [
        "microservice", "[^a-zA-Z0-9]", "-"
      ]
      lowercase => [ "microservice" ]
    }
  }
  
  # Normalizar campo service_name se vier como array
  if [service_name] {
    if [service_name][0] {
      mutate {
        replace => { "service_name" => "%{[service_name][0]}" }
      }
    }
  }
  
  # Normalizar campo service_port se vier como array
  if [service_port] {
    if [service_port][0] {
      mutate {
        replace => { "service_port" => "%{[service_port][0]}" }
      }
    }
  }
  
  # Determinar microservice final baseado nos campos disponíveis
  if ![microservice] or [microservice] == "" {
    if [service_name] {
      if "Games" in [service_name] or "games" in [service_name] {
        mutate {
          add_field => { "microservice" => "games-api" }
        }
      } else if "Users" in [service_name] or "users" in [service_name] {
        mutate {
          add_field => { "microservice" => "users-api" }
        }
      } else if "Payments" in [service_name] or "payments" in [service_name] {
        mutate {
          add_field => { "microservice" => "payments-api" }
        }
      } else {
        mutate {
          add_field => { "microservice" => "unknown" }
        }
      }
    } else {
      mutate {
        add_field => { "microservice" => "unknown" }
      }
    }
  }
  
  # Parse .NET structured logs from Serilog
  if [Properties] {
    # Extract correlation ID for distributed tracing
    if [Properties][CorrelationId] {
      mutate {
        add_field => { "correlation_id" => "%{[Properties][CorrelationId]}" }
      }
    }
    
    # Extract HTTP request information
    if [Properties][RequestPath] {
      mutate {
        add_field => { "request_path" => "%{[Properties][RequestPath]}" }
      }
    }
    
    if [Properties][RequestMethod] {
      mutate {
        add_field => { "request_method" => "%{[Properties][RequestMethod]}" }
      }
    }
    
    if [Properties][StatusCode] {
      mutate {
        add_field => { "status_code" => "%{[Properties][StatusCode]}" }
      }
    }
    
    if [Properties][Elapsed] {
      mutate {
        add_field => { "response_time_ms" => "%{[Properties][Elapsed]}" }
      }
    }
  }
  
  # Parse timestamp to Elasticsearch format
  if [Timestamp] {
    date {
      match => [ "Timestamp", "ISO8601" ]
    }
  }
  
  # Categorize log levels
  if [Level] {
    if [Level] == "Error" or [Level] == "Fatal" {
      mutate {
        add_field => { "log_category" => "error" }
      }
    } else if [Level] == "Warning" {
      mutate {
        add_field => { "log_category" => "warning" }
      }
    } else if [Level] == "Information" {
      mutate {
        add_field => { "log_category" => "info" }
      }
    } else {
      mutate {
        add_field => { "log_category" => "debug" }
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "fiap-logs-%{microservice}-%{+YYYY.MM.dd}"
  }
  
  # Debug output (opcional - pode ser removido em produção)
  stdout {
    codec => rubydebug
  }
}